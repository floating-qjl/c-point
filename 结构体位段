#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
//位段的声明和结构体是类似的，有两个不同：
//1.位段的成员一般必须是int、unsigned int 或 signed int（经过测试得，成员可以是任何整形）
//2.位段的成员名后面有一个冒号和一个数字
//3.位段通常是相同的类型

struct S
{
	int a : 2;// 只需要 2 bit就可以表示 4 种状态
	int b : 5;// 5 bit
	int c : 10;// 10 bit
	int d : 30;// 30 bit
};
//位段，是按二进制位
//一共是 47 bit - 6 个字节*8 = 48 bit

//位段的内存分配规则
//1.位段的成员可以是int、unsigned int、signed int 或者是 char(属于整形家族)类型
//2.位段的空间上是按照需要以四个字节或者一个字节的方式来开辟的
//3.位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段
//例如：c语言本身就没有规定内存是 从左向右 占有还是 从右向左 ，因此每个编译器的规定可能不一样

//首先开辟 4 个字节的空间，将 a b c 存储进去，剩下的15个字节无法存放 d
//因此再次开辟 4 个字节的空间，并将 d 存放进去，且元素大小不能超过 32 个bit （ 4 个字节）
//若想只开辟 1 个字节的空间，需要使用 char 类型
//最终得到答案，8 个字节

//位段可以进行 节省空间 ，如果此处不使用位段则会占有 16 个字节

struct A
{
	char a : 3;
	char b : 4;
	char c : 5;
	char d : 4;
};




int main()
{
	struct S s1;
	printf("%d\n", sizeof(s1));//8

	struct A s2 = { 0 };
	s2.a = 10;//1010，存储低位的 3 bit即 010
	s2.b = 20;//10100，存储低位的 4 bit即 0100
	s2.c = 3;//011，存储 5 bit即 00011
	s2.d = 4;//100，存储 4 bit即 0100
	//每个字节空间 从右向左 存储后，转化为 16 进制，为0010 0010 0000 0011 0000 0100 -> 22 03 04
	//使用 vs 查看内存，发现吻合，说明 vs 从右向左储存


	//位段中的跨平台问题：
	//1.int 位段被当成有符号数还是无符号数是不确定的
	//  开辟的四个字节最高位是不是被当作符号位，C语言未规定
	//2.位段中最大位的数目不确定。（16位机器中最大为16，32位机器最大为32，比如27在16位机器会出问题）
	//3.位段中的成员在内存中 从左向右 分配，还是 从右向左 分配标准尚未定义
	//4.当一个结构包含 两个位段 ，第 二 个位段成员比较 大 ，无法 容纳 于第 一 个位段剩余的位时
	//  是舍弃剩余的位还是利用，这是不能确定的。

	//总结：和结构体相比，位段可以达到相同的效果，而且可以很好的节省空间，但是有跨平台的问题存在
	return 0;
}
