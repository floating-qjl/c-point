#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
//结构体内存对齐
struct s1
{
	char a;
	int h;
	char a2 ;
};
//|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |
//|  |  |  |  |  |  |  |  |  |  |  |  |  |  |
//   0  1  2  3  4  5  6  7  8  9 10  11 12 13
//      偏移量
//   |  |        |  |  |  |  |  |  
//     a               h      a2  
struct s2
{
	char c1;
	char c2;
	int a;
};
//结构体的对齐规则：
//1.第一个成员在与结构体变量偏移量为0的地址处（最开始的内存空间处）
//2.其他成员变量要对齐到某个数字（对齐数）的 整数倍 的 地址处
//3.结构体总大小为最大对齐数的整数倍
//对齐数 = 编译器默认的一个对齐数 与 该成员大小的较小值
//   VS 默认对齐数为8
//例如 ：此时第二个结构体元素为 h 有4个字节，对齐数为 8 ，4 < 8 ，此处对齐数即为4
//也就是说， h 的第一个字节储存在a向下偏移量为 4 的地址处，而 h 包含4个字节
//中间的空白空间浪费掉了
//其他元素的对齐储存为 相同原理
//例如 a2 为1个字节，对齐数就为1，而h的末尾向后对齐1的倍数，实际上就是h的末尾地址
//这时候 s1 总大小为 9 个字节，又因为是最大对齐数（4）的整数倍，所以要向后再浪费3个字节
//   每个元素只需要找到其对齐数的整数倍位置即可（从初始位置开始数）


struct s3
{
	double d;
	char c;
	int i;
};
struct s4
{
	char c1;
	struct s3 s3;
	double d;
};
//在嵌套结构体的情况下，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小
//就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍

//此处 s3 的大小为 16 个字节，从偏移量为 0 处向下寻找 s3中最大对齐数 8 的倍数，浪费 7 个字节
//再向下占有16个字节，此时 s3 末端偏移量为 24 ，是 8 的倍数，因此 d 不需要再浪费空间
//向下占有 8 个字节，总共占有 32 个字节，为所有最大对齐数 8 的倍数，即符合条件
int main()
{
	struct s1 s1 = { 0 };
	struct s2 s2 = { 0 };
	struct s3 s3 = { 0 };
	struct s4 s4 = { 0 };
	printf("%d\n", sizeof(s1));
	printf("%d\n", sizeof(s2));
	printf("%d\n", sizeof(s3));
	printf("%d\n", sizeof(s4));
	return 0;
}
//1.平台移植：不是所有的硬件平台都能访问任意地址上的任意数据；某些平台只能在某些地址处取某些特定类型的数据，
//否则抛出硬件异常
//2.性能原因：数据结构应该尽可能地在自然边界上对齐。原因在于，为了访问未对其的内存，
// 处理器需要作两次内存访问，而对齐的内存访问仅需要一次访问
// 当读取结构体元素的时候，一次性读取相应的字节，不一定能完全读取所需的元素所占总空间大小
// 而如果对齐，则能使读取的位置快速指向元素的起始地址，再读取相应字节，只需要一次即可
//总体来说：结构体内存对齐是拿空间来换取时间的做法
